<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WSSTV - Web-Based SSTV Protocol</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #1a252f;
            --success: #27ae60;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, var(--primary) 0%, var(--dark) 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            color: var(--secondary);
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            color: var(--light);
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 900px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        h2 {
            color: var(--secondary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--secondary);
            font-size: 1.8rem;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        button, .file-input-label {
            background: var(--secondary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover, .file-input-label:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .file-input {
            display: none;
        }

        .slider-container {
            margin: 20px 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--light);
        }

        .slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
        }

        .status {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid var(--secondary);
        }

        .status h3 {
            color: var(--secondary);
            margin-bottom: 10px;
        }

        .status-text {
            font-family: monospace;
            white-space: pre-wrap;
            line-height: 1.5;
        }

        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }

        @media (max-width: 600px) {
            .visualization {
                grid-template-columns: 1fr;
            }
        }

        .image-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-container img, .image-container canvas {
            max-width: 100%;
            max-height: 300px;
            object-fit: contain;
        }

        .waveform {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            height: 300px;
            position: relative;
        }

        .progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s ease;
        }

        .protocol-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .protocol-info h3 {
            color: var(--accent);
            margin-bottom: 10px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
        }

        .info-label {
            font-size: 0.9rem;
            color: #95a5a6;
        }

        .info-value {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--light);
        }

        .decoding-status {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
        }

        .led {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #7f8c8d;
        }

        .led.active {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        .legacy-formats {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .format-btn {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .format-btn:hover {
            background: rgba(52, 152, 219, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>WSSTV Protocol</h1>
            <div class="subtitle">Special SSTV Encoder/Decoder with Advanced Features</div>
        </header>

        <div class="main-grid">
            <div class="panel">
                <h2>Encoder</h2>
                <div class="controls">
                    <label class="file-input-label">
                        <input type="file" class="file-input" id="imageInput" accept="image/*">
                        üìÅ Select Image
                    </label>
                    <button id="encodeBtn">üîä Encode to Audio</button>
                    <button id="playBtn" disabled>‚ñ∂Ô∏è Play Audio</button>
                    <button id="stopBtn" disabled>‚èπÔ∏è Stop Audio</button>
                    <button id="saveBtn" disabled>üíæ Save Audio</button>
                </div>

                <div class="slider-container">
                    <label for="pixelDuration">Pixel Duration: <span id="pixelDurationValue">10</span> ms</label>
                    <input type="range" id="pixelDuration" class="slider" min="5" max="50" value="10" step="1">
                </div>

                <div class="slider-container">
                    <label for="resolution">Resolution: <span id="resolutionValue">Medium</span></label>
                    <input type="range" id="resolution" class="slider" min="1" max="3" value="2" step="1">
                </div>

                <div class="controls">
                    <button id="encodeRgb">üé® RGB Encoding</button>
                    <button id="encodeFm">üîÑ FM Encoding</button>
                    <button id="enableRle">üìâ Enable RLE</button>
                </div>

                <div class="status">
                    <h3>Encoding Status</h3>
                    <div class="status-text" id="encodeStatus">Ready to encode an image.</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="encodeProgress"></div>
                    </div>
                </div>

                <div class="image-container">
                    <img id="sourceImage" alt="Source image will appear here" style="display: none;">
                    <div id="noImageText">No image selected</div>
                </div>
            </div>

            <div class="panel">
                <h2>Decoder</h2>
                <div class="controls">
                    <label class="file-input-label">
                        <input type="file" class="file-input" id="audioInput" accept="audio/*">
                        üéµ Load Audio
                    </label>
                    <button id="decodeBtn" disabled>üîç Decode Audio</button>
                    <button id="realtimeBtn" disabled>üåê Real-time Decode</button>
                    <button id="saveImageBtn" disabled>üíæ Save Image</button>
                </div>

                <div class="legacy-formats">
                    <div>Legacy Formats:</div>
                    <button class="format-btn">Robot 36</button>
                    <button class="format-btn">Martin M1</button>
                    <button class="format-btn">Scottie S2</button>
                </div>

                <div class="decoding-status">
                    <div class="led" id="syncLed"></div>
                    <div id="decodeStatus">Waiting for audio...</div>
                </div>

                <div class="status">
                    <h3>Decoding Information</h3>
                    <div class="status-text" id="decodeInfo"></div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="decodeProgress"></div>
                    </div>
                </div>

                <div class="image-container">
                    <canvas id="decodedImage"></canvas>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>Waveform Visualization</h2>
            <div class="waveform">
                <canvas id="waveformCanvas"></canvas>
            </div>
        </div>

        <div class="protocol-info">
            <h3>Protocol Information</h3>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Current Protocol</div>
                    <div class="info-value" id="currentProtocol">WSSTV v1.0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Color Encoding</div>
                    <div class="info-value" id="colorEncoding">RGB Separate</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Compression</div>
                    <div class="info-value" id="compressionStatus">RLE Enabled</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Pixel Rate</div>
                    <div class="info-value" id="pixelRate">100 pixels/sec</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // WSSTV Protocol Implementation
        class WSSTVProtocol {
            constructor() {
                this.audioContext = null;
                this.sourceNode = null;
                this.isPlaying = false;
                this.audioBuffer = null;
                this.currentImage = null;
                this.encodedData = null;
                
                // Protocol parameters
                this.pixelDuration = 0.01; // 10ms default
                this.resolution = 2; // 1=Low, 2=Medium, 3=High
                this.useRLE = true;
                this.colorEncoding = 'rgb'; // 'rgb', 'fm'
                
                // Frequency ranges (Hz)
                this.startFreq = 1900;
                this.syncFreq = 1200;
                this.visFreq = 1300;
                this.endFreq = 1500;
                this.colorFreqRange = { min: 1500, max: 2300 };
                
                // Metadata
                this.version = '1.0';
                this.headerLength = 100; // ms
            }

            // Initialize audio context
            initAudio() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            // Convert image to audio
            async encodeImage(imageData, width, height) {
                this.updateStatus('Encoding image to WSSTV protocol...');
                
                // Adjust pixel duration based on resolution
                const durationFactor = 1 / this.resolution;
                const adjustedPixelDuration = this.pixelDuration * durationFactor;
                
                // Calculate total duration
                const headerDuration = 0.5; // 500ms header
                const pixels = width * height;
                const totalDuration = headerDuration + (pixels * adjustedPixelDuration * 
                    (this.colorEncoding === 'rgb' ? 3 : 1));
                
                // Create audio buffer
                const sampleRate = this.audioContext.sampleRate;
                const buffer = this.audioContext.createBuffer(1, 
                    Math.ceil(totalDuration * sampleRate), sampleRate);
                const channelData = buffer.getChannelData(0);
                
                // Generate header tones
                this.generateHeader(channelData, sampleRate, width, height, 0);
                
                // Generate pixel data
                let position = Math.ceil(headerDuration * sampleRate);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const r = imageData[idx];
                        const g = imageData[idx + 1];
                        const b = imageData[idx + 2];
                        
                        if (this.useRLE) {
                            // Check for run-length encoding opportunity
                            let runLength = 1;
                            while (x + runLength < width) {
                                const nextIdx = (y * width + (x + runLength)) * 4;
                                if (imageData[nextIdx] === r && 
                                    imageData[nextIdx + 1] === g && 
                                    imageData[nextIdx + 2] === b) {
                                    runLength++;
                                } else {
                                    break;
                                }
                            }
                            
                            if (runLength > 3) {
                                // Encode run length
                                this.generateRunLength(channelData, sampleRate, position, runLength);
                                position += Math.ceil(adjustedPixelDuration * sampleRate);
                                x += runLength - 1;
                                continue;
                            }
                        }
                        
                        if (this.colorEncoding === 'rgb') {
                            // RGB separate encoding
                            this.generateTone(channelData, sampleRate, position, 
                                this.mapColorToFreq(r), adjustedPixelDuration);
                            position += Math.ceil(adjustedPixelDuration * sampleRate);
                            
                            this.generateTone(channelData, sampleRate, position, 
                                this.mapColorToFreq(g), adjustedPixelDuration);
                            position += Math.ceil(adjustedPixelDuration * sampleRate);
                            
                            this.generateTone(channelData, sampleRate, position, 
                                this.mapColorToFreq(b), adjustedPixelDuration);
                            position += Math.ceil(adjustedPixelDuration * sampleRate);
                        } else {
                            // FM encoding (all colors in one tone)
                            this.generateFMTone(channelData, sampleRate, position, 
                                r, g, b, adjustedPixelDuration);
                            position += Math.ceil(adjustedPixelDuration * sampleRate);
                        }
                        
                        // Update progress
                        if ((y * width + x) % 100 === 0) {
                            const progress = ((y * width + x) / (width * height)) * 100;
                            this.updateProgress(progress);
                        }
                    }
                }
                
                // Generate end tone
                this.generateTone(channelData, sampleRate, position, this.endFreq, 0.1);
                
                this.audioBuffer = buffer;
                this.updateStatus(`Encoding complete! Duration: ${totalDuration.toFixed(2)}s`);
                this.updateProgress(100);
                return buffer;
            }

            // Generate header tones
            generateHeader(channelData, sampleRate, width, height, startPos) {
                // Start tone
                this.generateTone(channelData, sampleRate, startPos, this.startFreq, 0.1);
                let pos = startPos + Math.ceil(0.1 * sampleRate);
                
                // Sync tone
                this.generateTone(channelData, sampleRate, pos, this.syncFreq, 0.05);
                pos += Math.ceil(0.05 * sampleRate);
                
                // VIS code for metadata
                this.generateTone(channelData, sampleRate, pos, this.visFreq, 0.05);
                pos += Math.ceil(0.05 * sampleRate);
                
                // Encode width and height
                this.encodeNumber(channelData, sampleRate, pos, width);
                pos += Math.ceil(0.05 * sampleRate);
                
                this.encodeNumber(channelData, sampleRate, pos, height);
                pos += Math.ceil(0.05 * sampleRate);
                
                // Protocol version
                this.encodeNumber(channelData, sampleRate, pos, parseInt(this.version.replace('.', '')));
            }

            // Generate a single tone
            generateTone(channelData, sampleRate, startPos, frequency, duration) {
                const sampleCount = Math.ceil(duration * sampleRate);
                const angularFreq = 2 * Math.PI * frequency / sampleRate;
                
                for (let i = 0; i < sampleCount; i++) {
                    const pos = startPos + i;
                    if (pos < channelData.length) {
                        // Apply envelope to avoid clicks
                        const envelope = this.getEnvelope(i, sampleCount);
                        channelData[pos] = Math.sin(angularFreq * i) * envelope * 0.5;
                    }
                }
            }

            // Generate FM tone for color encoding
            generateFMTone(channelData, sampleRate, startPos, r, g, b, duration) {
                const sampleCount = Math.ceil(duration * sampleRate);
                const baseFreq = 1500;
                
                // Modulate frequency based on RGB values
                const rMod = (r / 255) * 200;
                const gMod = (g / 255) * 200;
                const bMod = (b / 255) * 200;
                
                for (let i = 0; i < sampleCount; i++) {
                    const pos = startPos + i;
                    if (pos < channelData.length) {
                        // Combine modulations
                        const modulation = (Math.sin(2 * Math.PI * rMod * i / sampleRate) * 0.3 +
                                          Math.sin(2 * Math.PI * gMod * i / sampleRate) * 0.3 +
                                          Math.sin(2 * Math.PI * bMod * i / sampleRate) * 0.3);
                        
                        const freq = baseFreq + modulation * 400;
                        const angularFreq = 2 * Math.PI * freq / sampleRate;
                        const envelope = this.getEnvelope(i, sampleCount);
                        
                        channelData[pos] = Math.sin(angularFreq * i) * envelope * 0.5;
                    }
                }
            }

            // Generate run-length encoding marker
            generateRunLength(channelData, sampleRate, startPos, length) {
                // Special frequency for RLE marker
                const markerFreq = 2500;
                const duration = 0.01;
                this.generateTone(channelData, sampleRate, startPos, markerFreq, duration);
                
                // Encode length in next tone
                const lengthFreq = 1000 + (Math.min(length, 255) * 5);
                this.generateTone(channelData, sampleRate, startPos + Math.ceil(duration * sampleRate), 
                                lengthFreq, duration);
            }

            // Map color value to frequency
            mapColorToFreq(value) {
                return this.colorFreqRange.min + 
                       (value / 255) * (this.colorFreqRange.max - this.colorFreqRange.min);
            }

            // Encode a number as tone sequence
            encodeNumber(channelData, sampleRate, startPos, number) {
                const digits = number.toString().split('').map(Number);
                let pos = startPos;
                
                for (const digit of digits) {
                    const freq = 1000 + (digit * 100);
                    this.generateTone(channelData, sampleRate, pos, freq, 0.02);
                    pos += Math.ceil(0.02 * sampleRate);
                }
            }

            // Get envelope for smooth transitions
            getEnvelope(sampleIndex, totalSamples) {
                const attack = totalSamples * 0.1;
                const release = totalSamples * 0.1;
                
                if (sampleIndex < attack) {
                    return sampleIndex / attack;
                } else if (sampleIndex > totalSamples - release) {
                    return (totalSamples - sampleIndex) / release;
                }
                return 1;
            }

            // Decode audio to image
            async decodeAudio(audioBuffer) {
                this.updateDecodeStatus('Analyzing audio...');
                this.setSyncLed(false);
                
                const sampleRate = audioBuffer.sampleRate;
                const channelData = audioBuffer.getChannelData(0);
                
                // Detect start tone
                const startPos = this.detectStartTone(channelData, sampleRate);
                if (startPos === -1) {
                    throw new Error('No WSSTV signal detected');
                }
                
                this.updateDecodeStatus('Signal detected, decoding metadata...');
                this.setSyncLed(true);
                
                // Decode metadata
                let pos = startPos + Math.ceil(0.1 * sampleRate); // Skip start tone
                pos += Math.ceil(0.05 * sampleRate); // Skip sync tone
                pos += Math.ceil(0.05 * sampleRate); // Skip VIS tone
                
                const width = this.decodeNumber(channelData, sampleRate, pos);
                pos += Math.ceil(0.05 * sampleRate);
                
                const height = this.decodeNumber(channelData, sampleRate, pos);
                pos += Math.ceil(0.05 * sampleRate);
                
                this.updateDecodeStatus(`Image size: ${width}x${height}`);
                
                // Create image buffer
                const imageData = new Uint8ClampedArray(width * height * 4);
                
                // Decode pixel data
                let pixelIndex = 0;
                const samplesPerPixel = Math.ceil(this.pixelDuration * sampleRate);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (pixelIndex * 4 >= imageData.length) break;
                        
                        let r, g, b;
                        
                        if (this.colorEncoding === 'rgb') {
                            // RGB separate decoding
                            r = this.decodeColorTone(channelData, sampleRate, pos);
                            pos += samplesPerPixel;
                            g = this.decodeColorTone(channelData, sampleRate, pos);
                            pos += samplesPerPixel;
                            b = this.decodeColorTone(channelData, sampleRate, pos);
                            pos += samplesPerPixel;
                        } else {
                            // FM decoding
                            const colors = this.decodeFMTone(channelData, sampleRate, pos, samplesPerPixel);
                            r = colors.r;
                            g = colors.g;
                            b = colors.b;
                            pos += samplesPerPixel;
                        }
                        
                        // Check for RLE
                        if (this.useRLE) {
                            const rleInfo = this.detectRLE(channelData, sampleRate, pos - samplesPerPixel);
                            if (rleInfo.isRLE) {
                                const runLength = rleInfo.length;
                                for (let i = 0; i < runLength; i++) {
                                    if (pixelIndex * 4 < imageData.length) {
                                        imageData[pixelIndex * 4] = r;
                                        imageData[pixelIndex * 4 + 1] = g;
                                        imageData[pixelIndex * 4 + 2] = b;
                                        imageData[pixelIndex * 4 + 3] = 255;
                                        pixelIndex++;
                                    }
                                }
                                x += runLength - 1;
                                continue;
                            }
                        }
                        
                        imageData[pixelIndex * 4] = r;
                        imageData[pixelIndex * 4 + 1] = g;
                        imageData[pixelIndex * 4 + 2] = b;
                        imageData[pixelIndex * 4 + 3] = 255;
                        pixelIndex++;
                        
                        // Update progress
                        if (pixelIndex % 100 === 0) {
                            const progress = (pixelIndex / (width * height)) * 100;
                            this.updateDecodeProgress(progress);
                        }
                    }
                }
                
                this.updateDecodeStatus('Decoding complete!');
                this.updateDecodeProgress(100);
                
                return { imageData, width, height };
            }

            // Detect start tone
            detectStartTone(channelData, sampleRate) {
                const windowSize = Math.ceil(0.05 * sampleRate);
                
                for (let i = 0; i < channelData.length - windowSize; i += windowSize) {
                    const segment = channelData.slice(i, i + windowSize);
                    const dominantFreq = this.getDominantFrequency(segment, sampleRate);
                    
                    if (Math.abs(dominantFreq - this.startFreq) < 50) {
                        return i;
                    }
                }
                return -1;
            }

            // Get dominant frequency using FFT
            getDominantFrequency(samples, sampleRate) {
                // Simplified frequency detection
                let maxAmplitude = 0;
                let maxFreq = 0;
                
                for (let freq = 500; freq <= 3000; freq += 50) {
                    let amplitude = 0;
                    const angularFreq = 2 * Math.PI * freq / sampleRate;
                    
                    for (let i = 0; i < samples.length; i++) {
                        amplitude += samples[i] * Math.cos(angularFreq * i);
                    }
                    
                    amplitude = Math.abs(amplitude) / samples.length;
                    
                    if (amplitude > maxAmplitude) {
                        maxAmplitude = amplitude;
                        maxFreq = freq;
                    }
                }
                
                return maxFreq;
            }

            // Decode number from tones
            decodeNumber(channelData, sampleRate, startPos) {
                let number = 0;
                let pos = startPos;
                
                for (let i = 0; i < 4; i++) {
                    const segment = channelData.slice(pos, pos + Math.ceil(0.02 * sampleRate));
                    const freq = this.getDominantFrequency(segment, sampleRate);
                    const digit = Math.round((freq - 1000) / 100);
                    
                    if (digit >= 0 && digit <= 9) {
                        number = number * 10 + digit;
                    }
                    pos += Math.ceil(0.02 * sampleRate);
                }
                
                return number;
            }

            // Decode color from tone
            decodeColorTone(channelData, sampleRate, startPos) {
                const segment = channelData.slice(startPos, startPos + Math.ceil(0.01 * sampleRate));
                const freq = this.getDominantFrequency(segment, sampleRate);
                
                // Map frequency back to color value
                return Math.round(((freq - this.colorFreqRange.min) / 
                                 (this.colorFreqRange.max - this.colorFreqRange.min)) * 255);
            }

            // Decode FM tone
            decodeFMTone(channelData, sampleRate, startPos, length) {
                const segment = channelData.slice(startPos, startPos + length);
                
                // Simplified FM decoding
                let r = 0, g = 0, b = 0;
                
                // Analyze frequency variations
                for (let i = 0; i < segment.length; i++) {
                    const sample = segment[i];
                    r += Math.abs(sample * Math.sin(2 * Math.PI * 50 * i / sampleRate));
                    g += Math.abs(sample * Math.sin(2 * Math.PI * 100 * i / sampleRate));
                    b += Math.abs(sample * Math.sin(2 * Math.PI * 150 * i / sampleRate));
                }
                
                // Normalize
                const scale = 255 / Math.max(r, g, b);
                return {
                    r: Math.round(r * scale),
                    g: Math.round(g * scale),
                    b: Math.round(b * scale)
                };
            }

            // Detect RLE marker
            detectRLE(channelData, sampleRate, pos) {
                const markerSegment = channelData.slice(pos, pos + Math.ceil(0.01 * sampleRate));
                const markerFreq = this.getDominantFrequency(markerSegment, sampleRate);
                
                if (Math.abs(markerFreq - 2500) < 100) {
                    const lengthSegment = channelData.slice(pos + Math.ceil(0.01 * sampleRate), 
                                                          pos + Math.ceil(0.02 * sampleRate));
                    const lengthFreq = this.getDominantFrequency(lengthSegment, sampleRate);
                    const length = Math.round((lengthFreq - 1000) / 5);
                    
                    return { isRLE: true, length: Math.min(length, 255) };
                }
                
                return { isRLE: false, length: 0 };
            }

            // Play audio
            playAudio(buffer) {
                if (!this.audioContext) this.initAudio();
                
                this.stopAudio();
                
                this.sourceNode = this.audioContext.createBufferSource();
                this.sourceNode.buffer = buffer;
                this.sourceNode.connect(this.audioContext.destination);
                
                this.sourceNode.onended = () => {
                    this.isPlaying = false;
                    this.updatePlaybackStatus('Stopped');
                };
                
                this.sourceNode.start();
                this.isPlaying = true;
                this.updatePlaybackStatus('Playing...');
            }

            // Stop audio
            stopAudio() {
                if (this.sourceNode) {
                    this.sourceNode.stop();
                    this.sourceNode.disconnect();
                    this.sourceNode = null;
                }
                this.isPlaying = false;
                this.updatePlaybackStatus('Stopped');
            }

            // Save audio as WAV file
            saveAudioAsWAV(buffer, filename = 'wsstv_transmission.wav') {
                const wavBuffer = this.bufferToWav(buffer);
                const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // Convert AudioBuffer to WAV
            bufferToWav(buffer) {
                const numChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const format = 1; // PCM
                const bitDepth = 16;
                
                const bytesPerSample = bitDepth / 8;
                const blockAlign = numChannels * bytesPerSample;
                
                const wavData = new DataView(new ArrayBuffer(44 + buffer.length * blockAlign));
                
                // Write WAV header
                this.writeString(wavData, 0, 'RIFF');
                wavData.setUint32(4, 36 + buffer.length * blockAlign, true);
                this.writeString(wavData, 8, 'WAVE');
                this.writeString(wavData, 12, 'fmt ');
                wavData.setUint32(16, 16, true);
                wavData.setUint16(20, format, true);
                wavData.setUint16(22, numChannels, true);
                wavData.setUint32(24, sampleRate, true);
                wavData.setUint32(28, sampleRate * blockAlign, true);
                wavData.setUint16(32, blockAlign, true);
                wavData.setUint16(34, bitDepth, true);
                this.writeString(wavData, 36, 'data');
                wavData.setUint32(40, buffer.length * blockAlign, true);
                
                // Write audio data
                let offset = 44;
                for (let i = 0; i < buffer.length; i++) {
                    for (let channel = 0; channel < numChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        wavData.setInt16(offset, sample * 0x7FFF, true);
                        offset += 2;
                    }
                }
                
                return wavData;
            }

            writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            // Update methods
            updateStatus(text) {
                document.getElementById('encodeStatus').textContent = text;
            }

            updateProgress(percent) {
                document.getElementById('encodeProgress').style.width = percent + '%';
            }

            updateDecodeStatus(text) {
                document.getElementById('decodeStatus').textContent = text;
            }

            updateDecodeProgress(percent) {
                document.getElementById('decodeProgress').style.width = percent + '%';
            }

            updateDecodeInfo(text) {
                document.getElementById('decodeInfo').textContent = text;
            }

            updatePlaybackStatus(text) {
                const btn = document.getElementById('playBtn');
                btn.innerHTML = this.isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
                btn.disabled = !this.audioBuffer;
            }

            setSyncLed(active) {
                document.getElementById('syncLed').classList.toggle('active', active);
            }

            updateProtocolInfo() {
                document.getElementById('pixelRate').textContent = 
                    `${Math.round(1000 / (this.pixelDuration * 1000))} pixels/sec`;
                document.getElementById('colorEncoding').textContent = 
                    this.colorEncoding === 'rgb' ? 'RGB Separate' : 'FM Encoding';
                document.getElementById('compressionStatus').textContent = 
                    this.useRLE ? 'RLE Enabled' : 'No Compression';
            }
        }

        // Application Controller
        class WSSTVApp {
            constructor() {
                this.protocol = new WSSTVProtocol();
                this.init();
            }

            init() {
                this.bindEvents();
                this.initCanvas();
                this.protocol.updateProtocolInfo();
            }

            bindEvents() {
                // Image selection
                document.getElementById('imageInput').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0]);
                });

                // Encoding
                document.getElementById('encodeBtn').addEventListener('click', () => {
                    this.encodeCurrentImage();
                });

                // Playback
                document.getElementById('playBtn').addEventListener('click', () => {
                    if (this.protocol.isPlaying) {
                        this.protocol.stopAudio();
                    } else if (this.protocol.audioBuffer) {
                        this.protocol.playAudio(this.protocol.audioBuffer);
                    }
                });

                document.getElementById('stopBtn').addEventListener('click', () => {
                    this.protocol.stopAudio();
                });

                // Save audio
                document.getElementById('saveBtn').addEventListener('click', () => {
                    if (this.protocol.audioBuffer) {
                        this.protocol.saveAudioAsWAV(this.protocol.audioBuffer);
                    }
                });

                // Settings
                document.getElementById('pixelDuration').addEventListener('input', (e) => {
                    this.protocol.pixelDuration = e.target.value / 1000;
                    document.getElementById('pixelDurationValue').textContent = e.target.value;
                    this.protocol.updateProtocolInfo();
                });

                document.getElementById('resolution').addEventListener('input', (e) => {
                    this.protocol.resolution = parseInt(e.target.value);
                    const resolutions = ['Low', 'Medium', 'High'];
                    document.getElementById('resolutionValue').textContent = resolutions[e.target.value - 1];
                    this.protocol.updateProtocolInfo();
                });

                // Encoding modes
                document.getElementById('encodeRgb').addEventListener('click', () => {
                    this.protocol.colorEncoding = 'rgb';
                    document.getElementById('colorEncoding').textContent = 'RGB Separate';
                });

                document.getElementById('encodeFm').addEventListener('click', () => {
                    this.protocol.colorEncoding = 'fm';
                    document.getElementById('colorEncoding').textContent = 'FM Encoding';
                });

                document.getElementById('enableRle').addEventListener('click', (e) => {
                    this.protocol.useRLE = !this.protocol.useRLE;
                    e.target.textContent = this.protocol.useRLE ? 
                        'üìâ Enable RLE' : 'üìà Disable RLE';
                    this.protocol.updateProtocolInfo();
                });

                // Audio file input
                document.getElementById('audioInput').addEventListener('change', (e) => {
                    this.loadAudioFile(e.target.files[0]);
                });

                // Decoding
                document.getElementById('decodeBtn').addEventListener('click', () => {
                    this.decodeAudio();
                });

                // Save image
                document.getElementById('saveImageBtn').addEventListener('click', () => {
                    this.saveDecodedImage();
                });
            }

            initCanvas() {
                this.waveformCanvas = document.getElementById('waveformCanvas');
                this.decodedCanvas = document.getElementById('decodedImage');
                
                // Set canvas dimensions
                const resizeCanvas = () => {
                    const waveformContainer = document.querySelector('.waveform');
                    this.waveformCanvas.width = waveformContainer.clientWidth - 30;
                    this.waveformCanvas.height = waveformContainer.clientHeight - 30;
                    
                    this.decodedCanvas.width = 400;
                    this.decodedCanvas.height = 300;
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }

            async loadImage(file) {
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Resize if too large
                        const maxSize = 400;
                        let width = img.width;
                        let height = img.height;
                        
                        if (width > maxSize || height > maxSize) {
                            const ratio = Math.min(maxSize / width, maxSize / height);
                            width = Math.floor(width * ratio);
                            height = Math.floor(height * ratio);
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        this.protocol.currentImage = {
                            data: ctx.getImageData(0, 0, width, height),
                            width,
                            height
                        };
                        
                        // Display image
                        document.getElementById('sourceImage').src = e.target.result;
                        document.getElementById('sourceImage').style.display = 'block';
                        document.getElementById('noImageText').style.display = 'none';
                        
                        // Enable encode button
                        document.getElementById('encodeBtn').disabled = false;
                        
                        this.protocol.updateStatus(`Image loaded: ${width}x${height}`);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            async encodeCurrentImage() {
                if (!this.protocol.currentImage) {
                    alert('Please select an image first!');
                    return;
                }
                
                try {
                    this.protocol.initAudio();
                    
                    const { data, width, height } = this.protocol.currentImage;
                    const audioBuffer = await this.protocol.encodeImage(data, width, height);
                    
                    // Enable playback controls
                    document.getElementById('playBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('saveBtn').disabled = false;
                    
                    // Draw waveform
                    this.drawWaveform(audioBuffer);
                    
                } catch (error) {
                    console.error('Encoding error:', error);
                    this.protocol.updateStatus(`Error: ${error.message}`);
                }
            }

            async loadAudioFile(file) {
                if (!file) return;
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.protocol.initAudio();
                    const audioBuffer = await this.protocol.audioContext.decodeAudioData(arrayBuffer);
                    
                    this.protocol.audioBuffer = audioBuffer;
                    document.getElementById('decodeBtn').disabled = false;
                    document.getElementById('realtimeBtn').disabled = false;
                    
                    this.protocol.updateDecodeStatus(`Audio loaded: ${audioBuffer.duration.toFixed(2)}s`);
                    this.drawWaveform(audioBuffer);
                    
                } catch (error) {
                    console.error('Audio loading error:', error);
                    this.protocol.updateDecodeStatus(`Error: ${error.message}`);
                }
            }

            async decodeAudio() {
                if (!this.protocol.audioBuffer) {
                    alert('Please load an audio file first!');
                    return;
                }
                
                try {
                    const result = await this.protocol.decodeAudio(this.protocol.audioBuffer);
                    
                    // Display decoded image
                    const canvas = this.decodedCanvas;
                    const ctx = canvas.getContext('2d');
                    const imageData = new ImageData(result.imageData, result.width, result.height);
                    
                    canvas.width = result.width;
                    canvas.height = result.height;
                    ctx.putImageData(imageData, 0, 0);
                    
                    document.getElementById('saveImageBtn').disabled = false;
                    
                    this.protocol.updateDecodeInfo(
                        `Decoded: ${result.width}x${result.height}\n` +
                        `Format: WSSTV v${this.protocol.version}\n` +
                        `Encoding: ${this.protocol.colorEncoding.toUpperCase()}`
                    );
                    
                } catch (error) {
                    console.error('Decoding error:', error);
                    this.protocol.updateDecodeStatus(`Error: ${error.message}`);
                }
            }

            drawWaveform(audioBuffer) {
                const canvas = this.waveformCanvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                // Draw grid
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                
                // Horizontal lines
                for (let i = 0; i <= 5; i++) {
                    const y = (i / 5) * height;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // Get channel data
                const data = audioBuffer.getChannelData(0);
                const step = Math.ceil(data.length / width);
                const amp = height / 2;
                
                // Draw waveform
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < width; i++) {
                    const index = Math.min(Math.floor(i * step), data.length - 1);
                    const value = data[index];
                    const x = i;
                    const y = amp + (value * amp * 0.8);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Mark start and end
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(0, 0, 4, height);
                ctx.fillRect(width - 4, 0, 4, height);
            }

            saveDecodedImage() {
                const canvas = this.decodedCanvas;
                const link = document.createElement('a');
                link.download = 'wsstv_decoded_image.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
        }

        // Initialize application when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new WSSTVApp();
        });
    </script>
</body>
  </html>
