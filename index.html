
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WSSTV - Web-Based SSTV Protocol</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #1a252f;
            --success: #27ae60;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, var(--primary) 0%, var(--dark) 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            color: var(--secondary);
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            color: var(--light);
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 900px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        h2 {
            color: var(--secondary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--secondary);
            font-size: 1.8rem;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        button, .file-input-label {
            background: var(--secondary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover, .file-input-label:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .file-input {
            display: none;
        }

        .slider-container {
            margin: 20px 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--light);
        }

        .slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
        }

        .status {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid var(--secondary);
        }

        .status h3 {
            color: var(--secondary);
            margin-bottom: 10px;
        }

        .status-text {
            font-family: monospace;
            white-space: pre-wrap;
            line-height: 1.5;
        }

        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }

        @media (max-width: 600px) {
            .visualization {
                grid-template-columns: 1fr;
            }
        }

        .image-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-container img, .image-container canvas {
            max-width: 100%;
            max-height: 300px;
            object-fit: contain;
        }

        .waveform {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            height: 300px;
            position: relative;
        }

        .progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s ease;
        }

        .protocol-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .protocol-info h3 {
            color: var(--accent);
            margin-bottom: 10px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
        }

        .info-label {
            font-size: 0.9rem;
            color: #95a5a6;
        }

        .info-value {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--light);
        }

        .decoding-status {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
        }

        .led {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #7f8c8d;
        }

        .led.active {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        .led.recording {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .frequency-display {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .frequency-meter {
            height: 20px;
            background: linear-gradient(90deg, 
                #27ae60 0%, 
                #2ecc71 20%, 
                #f1c40f 40%, 
                #e67e22 60%, 
                #e74c3c 80%, 
                #c0392b 100%);
            border-radius: 10px;
            position: relative;
            margin-top: 10px;
        }

        .frequency-marker {
            position: absolute;
            top: -5px;
            width: 2px;
            height: 30px;
            background: white;
            transform: translateX(-50%);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            background: var(--accent);
            color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
        }

        .notification.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="notification" id="notification"></div>
    <div class="container">
        <header>
            <h1>WSSTV Protocol</h1>
            <div class="subtitle">Special SSTV Encoder/Decoder with Microphone Support</div>
        </header>

        <div class="main-grid">
            <div class="panel">
                <h2>Encoder</h2>
                <div class="controls">
                    <label class="file-input-label">
                        <input type="file" class="file-input" id="imageInput" accept="image/*">
                        üìÅ Select Image
                    </label>
                    <button id="encodeBtn" disabled>üîä Encode to Audio</button>
                    <button id="playBtn" disabled>‚ñ∂Ô∏è Play Audio</button>
                    <button id="stopBtn" disabled>‚èπÔ∏è Stop Audio</button>
                    <button id="saveBtn" disabled>üíæ Save Audio</button>
                </div>

                <div class="slider-container">
                    <label for="pixelDuration">Pixel Duration: <span id="pixelDurationValue">15</span> ms</label>
                    <input type="range" id="pixelDuration" class="slider" min="5" max="50" value="15" step="1">
                </div>

                <div class="slider-container">
                    <label for="resolution">Resolution Scale: <span id="resolutionValue">0.5</span></label>
                    <input type="range" id="resolution" class="slider" min="1" max="10" value="5" step="1">
                </div>

                <div class="controls">
                    <button id="encodeRgb" class="active">üé® RGB Encoding</button>
                    <button id="encodeFm">üîÑ FM Encoding</button>
                    <button id="enableRle" class="active">üìâ RLE Enabled</button>
                </div>

                <div class="status">
                    <h3>Encoding Status</h3>
                    <div class="status-text" id="encodeStatus">Select an image to encode.</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="encodeProgress"></div>
                    </div>
                </div>

                <div class="image-container">
                    <img id="sourceImage" alt="Source image will appear here" style="display: none;">
                    <div id="noImageText">No image selected</div>
                </div>
            </div>

            <div class="panel">
                <h2>Decoder</h2>
                <div class="controls">
                    <label class="file-input-label">
                        <input type="file" class="file-input" id="audioInput" accept="audio/*">
                        üéµ Load Audio
                    </label>
                    <button id="decodeBtn" disabled>üîç Decode Audio File</button>
                    <button id="micBtn">üé§ Decode from Microphone</button>
                    <button id="saveImageBtn" disabled>üíæ Save Image</button>
                </div>

                <div class="frequency-display">
                    <div>Current Frequency: <span id="currentFreq">-- Hz</span></div>
                    <div class="frequency-meter">
                        <div class="frequency-marker" id="freqMarker"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                        <span>800 Hz</span>
                        <span>3000 Hz</span>
                    </div>
                </div>

                <div class="decoding-status">
                    <div class="led" id="syncLed"></div>
                    <div id="decodeStatus">Ready to decode.</div>
                </div>

                <div class="status">
                    <h3>Decoding Information</h3>
                    <div class="status-text" id="decodeInfo"></div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="decodeProgress"></div>
                    </div>
                </div>

                <div class="image-container">
                    <canvas id="decodedImage"></canvas>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>Audio Visualization</h2>
            <div class="waveform">
                <canvas id="waveformCanvas"></canvas>
            </div>
        </div>

        <div class="protocol-info">
            <h3>Protocol Information</h3>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Protocol Version</div>
                    <div class="info-value" id="currentProtocol">WSSTV v2.0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Color Encoding</div>
                    <div class="info-value" id="colorEncoding">RGB Separate</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Compression</div>
                    <div class="info-value" id="compressionStatus">RLE Enabled</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Pixel Rate</div>
                    <div class="info-value" id="pixelRate">67 pixels/sec</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // WSSTV Protocol Implementation - FIXED VERSION
        class WSSTVProtocol {
            constructor() {
                this.audioContext = null;
                this.sourceNode = null;
                this.isPlaying = false;
                this.audioBuffer = null;
                this.currentImage = null;
                
                // Protocol parameters
                this.pixelDuration = 0.015; // 15ms default
                this.resolutionScale = 0.5; // Scale factor
                this.useRLE = true;
                this.colorEncoding = 'rgb'; // 'rgb', 'fm'
                
                // Frequency ranges (Hz) - Updated for better detection
                this.startFreq = 1900;
                this.syncFreq = 1200;
                this.visFreq = 1300;
                this.endFreq = 1500;
                this.blackFreq = 1500;
                this.whiteFreq = 2300;
                
                // Sampling
                this.sampleRate = 44100;
                
                // Decoding state
                this.isDecoding = false;
                this.micStream = null;
                this.analyser = null;
                this.micProcessor = null;
            }

            // Initialize audio context
            initAudio() {
                if (!this.audioContext || this.audioContext.state === 'closed') {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.sampleRate
                    });
                }
                return this.audioContext;
            }

            // Show notification
            showNotification(message, type = 'info') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.style.background = type === 'error' ? '#e74c3c' : 
                                               type === 'success' ? '#27ae60' : '#3498db';
                notification.classList.add('show');
                setTimeout(() => notification.classList.remove('show'), 3000);
            }

            // Convert image to audio - FIXED
            async encodeImage(imageData, width, height) {
                this.updateStatus('Encoding image...');
                this.updateProgress(0);
                
                const ctx = this.initAudio();
                
                // Apply resolution scaling
                const scaledWidth = Math.floor(width * this.resolutionScale);
                const scaledHeight = Math.floor(height * this.resolutionScale);
                
                // Create scaled image data
                const scaledData = new Uint8ClampedArray(scaledWidth * scaledHeight * 4);
                const scaleX = width / scaledWidth;
                const scaleY = height / scaledHeight;
                
                for (let y = 0; y < scaledHeight; y++) {
                    for (let x = 0; x < scaledWidth; x++) {
                        const srcX = Math.floor(x * scaleX);
                        const srcY = Math.floor(y * scaleY);
                        const srcIdx = (srcY * width + srcX) * 4;
                        const dstIdx = (y * scaledWidth + x) * 4;
                        
                        scaledData[dstIdx] = imageData[srcIdx];
                        scaledData[dstIdx + 1] = imageData[srcIdx + 1];
                        scaledData[dstIdx + 2] = imageData[srcIdx + 2];
                        scaledData[dstIdx + 3] = 255;
                    }
                    this.updateProgress((y / scaledHeight) * 50);
                }
                
                // Calculate durations
                const headerDuration = 1.0; // 1 second header
                const pixelCount = scaledWidth * scaledHeight;
                const toneDuration = this.colorEncoding === 'rgb' ? this.pixelDuration * 3 : this.pixelDuration;
                const dataDuration = pixelCount * toneDuration;
                const totalDuration = headerDuration + dataDuration + 0.5; // + 0.5s for end tone
                
                // Create audio buffer
                const buffer = ctx.createBuffer(1, 
                    Math.ceil(totalDuration * this.sampleRate), this.sampleRate);
                const channelData = buffer.getChannelData(0);
                
                let sampleIndex = 0;
                
                // Generate header
                sampleIndex = this.generateHeader(channelData, sampleIndex, scaledWidth, scaledHeight);
                
                // Generate pixel data
                let pixelIndex = 0;
                for (let y = 0; y < scaledHeight; y++) {
                    for (let x = 0; x < scaledWidth; x++) {
                        const idx = (y * scaledWidth + x) * 4;
                        const r = scaledData[idx];
                        const g = scaledData[idx + 1];
                        const b = scaledData[idx + 2];
                        
                        if (this.useRLE && x > 0) {
                            const prevIdx = (y * scaledWidth + (x - 1)) * 4;
                            const prevR = scaledData[prevIdx];
                            const prevG = scaledData[prevIdx + 1];
                            const prevB = scaledData[prevIdx + 2];
                            
                            if (r === prevR && g === prevG && b === prevB) {
                                // Find run length
                                let runLength = 1;
                                while (x + runLength < scaledWidth) {
                                    const nextIdx = (y * scaledWidth + (x + runLength)) * 4;
                                    if (scaledData[nextIdx] === r && 
                                        scaledData[nextIdx + 1] === g && 
                                        scaledData[nextIdx + 2] === b) {
                                        runLength++;
                                    } else {
                                        break;
                                    }
                                }
                                
                                if (runLength > 2) {
                                    // Encode RLE
                                    sampleIndex = this.generateRLETone(channelData, sampleIndex, runLength);
                                    x += runLength - 1;
                                    pixelIndex += runLength;
                                    continue;
                                }
                            }
                        }
                        
                        if (this.colorEncoding === 'rgb') {
                            sampleIndex = this.generateColorTone(channelData, sampleIndex, r, 'r');
                            sampleIndex = this.generateColorTone(channelData, sampleIndex, g, 'g');
                            sampleIndex = this.generateColorTone(channelData, sampleIndex, b, 'b');
                        } else {
                            sampleIndex = this.generateFMTone(channelData, sampleIndex, r, g, b);
                        }
                        
                        pixelIndex++;
                        
                        // Update progress
                        if (pixelIndex % 100 === 0) {
                            const progress = 50 + (pixelIndex / pixelCount) * 50;
                            this.updateProgress(progress);
                        }
                    }
                }
                
                // End tone
                sampleIndex = this.generateTone(channelData, sampleIndex, this.endFreq, 0.5);
                
                this.audioBuffer = buffer;
                this.updateStatus(`Encoded ${scaledWidth}x${scaledHeight} image`);
                this.updateProgress(100);
                this.showNotification('Image encoded successfully!', 'success');
                
                return {
                    buffer,
                    width: scaledWidth,
                    height: scaledHeight
                };
            }

            // Generate header tones
            generateHeader(channelData, startIndex, width, height) {
                let index = startIndex;
                
                // Start sequence: 1900 Hz for 0.3s
                index = this.generateTone(channelData, index, this.startFreq, 0.3);
                
                // Sync: 1200 Hz for 0.1s
                index = this.generateTone(channelData, index, this.syncFreq, 0.1);
                
                // VIS: 1300 Hz for 0.1s
                index = this.generateTone(channelData, index, this.visFreq, 0.1);
                
                // Width encoding (two bytes)
                index = this.encodeNumber(channelData, index, width);
                
                // Height encoding (two bytes)
                index = this.encodeNumber(channelData, index, height);
                
                // Encoding type: 1 for RGB, 2 for FM
                index = this.encodeNumber(channelData, index, this.colorEncoding === 'rgb' ? 1 : 2);
                
                return index;
            }

            // Generate a simple tone
            generateTone(channelData, startIndex, freq, duration) {
                const sampleCount = Math.floor(duration * this.sampleRate);
                const endIndex = startIndex + sampleCount;
                const angularFreq = 2 * Math.PI * freq / this.sampleRate;
                
                for (let i = 0; i < sampleCount; i++) {
                    const idx = startIndex + i;
                    if (idx >= channelData.length) break;
                    
                    // Apply envelope
                    const envelope = this.getEnvelope(i, sampleCount);
                    channelData[idx] = Math.sin(angularFreq * i) * envelope * 0.7;
                }
                
                return endIndex;
            }

            // Generate color tone
            generateColorTone(channelData, startIndex, value, channel) {
                const freq = this.blackFreq + (value / 255) * (this.whiteFreq - this.blackFreq);
                return this.generateTone(channelData, startIndex, freq, this.pixelDuration);
            }

            // Generate FM tone
            generateFMTone(channelData, startIndex, r, g, b) {
                const duration = this.pixelDuration;
                const sampleCount = Math.floor(duration * this.sampleRate);
                const endIndex = startIndex + sampleCount;
                
                // Base frequency with modulation
                const baseFreq = 1900;
                const rMod = (r / 255) * 100;
                const gMod = (g / 255) * 100;
                const bMod = (b / 255) * 100;
                
                for (let i = 0; i < sampleCount; i++) {
                    const idx = startIndex + i;
                    if (idx >= channelData.length) break;
                    
                    // Combined modulation
                    const time = i / this.sampleRate;
                    const modulation = 
                        Math.sin(2 * Math.PI * rMod * time) * 0.3 +
                        Math.sin(2 * Math.PI * gMod * time + Math.PI/3) * 0.3 +
                        Math.sin(2 * Math.PI * bMod * time + 2*Math.PI/3) * 0.3;
                    
                    const freq = baseFreq + modulation * 400;
                    const angularFreq = 2 * Math.PI * freq / this.sampleRate;
                    const envelope = this.getEnvelope(i, sampleCount);
                    
                    channelData[idx] = Math.sin(angularFreq * i) * envelope * 0.7;
                }
                
                return endIndex;
            }

            // Generate RLE tone
            generateRLETone(channelData, startIndex, length) {
                // RLE marker: 2500 Hz for 0.02s
                let index = this.generateTone(channelData, startIndex, 2500, 0.02);
                
                // Length encoded as frequency: 1000 + length * 10 Hz
                const lengthFreq = 1000 + Math.min(length, 100) * 10;
                index = this.generateTone(channelData, index, lengthFreq, 0.02);
                
                return index;
            }

            // Encode number as dual-tone sequence
            encodeNumber(channelData, startIndex, number) {
                // Split into two bytes
                const byte1 = (number >> 8) & 0xFF;
                const byte2 = number & 0xFF;
                
                let index = startIndex;
                
                // First byte: 800 + byte * 8.6 Hz
                const freq1 = 800 + byte1 * 8.6;
                index = this.generateTone(channelData, index, freq1, 0.05);
                
                // Second byte
                const freq2 = 800 + byte2 * 8.6;
                index = this.generateTone(channelData, index, freq2, 0.05);
                
                return index;
            }

            // Get envelope for smooth transitions
            getEnvelope(sampleIndex, totalSamples) {
                const attack = Math.min(totalSamples * 0.1, 100);
                const release = Math.min(totalSamples * 0.1, 100);
                
                if (sampleIndex < attack) {
                    return sampleIndex / attack;
                } else if (sampleIndex > totalSamples - release) {
                    return (totalSamples - sampleIndex) / release;
                }
                return 1;
            }

            // Decode audio to image - FIXED
            async decodeAudio(audioBuffer) {
                this.updateDecodeStatus('Starting audio analysis...');
                this.updateDecodeProgress(0);
                this.setSyncLed(false);
                
                const ctx = this.initAudio();
                const channelData = audioBuffer.getChannelData(0);
                
                // Detect start of transmission
                const startPos = this.findStartOfSignal(channelData);
                if (startPos === -1) {
                    throw new Error('No valid WSSTV signal found');
                }
                
                this.updateDecodeStatus('Signal detected, decoding metadata...');
                this.setSyncLed(true);
                
                // Decode metadata
                let pos = startPos;
                
                // Skip start tone (we already detected it)
                pos += Math.floor(0.3 * this.sampleRate);
                
                // Skip sync tone
                pos += Math.floor(0.1 * this.sampleRate);
                
                // Skip VIS tone
                pos += Math.floor(0.1 * this.sampleRate);
                
                // Decode width and height
                const width = this.decodeNumber(channelData, pos);
                pos += Math.floor(0.1 * this.sampleRate);
                
                const height = this.decodeNumber(channelData, pos);
                pos += Math.floor(0.1 * this.sampleRate);
                
                // Decode encoding type
                const encodingType = this.decodeNumber(channelData, pos);
                pos += Math.floor(0.1 * this.sampleRate);
                
                this.colorEncoding = encodingType === 1 ? 'rgb' : 'fm';
                
                this.updateDecodeStatus(`Decoding ${width}x${height} image (${this.colorEncoding})`);
                this.updateDecodeInfo(`Width: ${width}, Height: ${height}, Encoding: ${this.colorEncoding}`);
                
                // Create image buffer
                const imageData = new Uint8ClampedArray(width * height * 4);
                let pixelIndex = 0;
                const samplesPerPixel = Math.floor(this.pixelDuration * this.sampleRate);
                
                // Decode pixel data
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (pixelIndex >= width * height) break;
                        
                        // Check for RLE
                        const rleCheck = this.checkForRLE(channelData, pos);
                        if (rleCheck.isRLE) {
                            pos = rleCheck.newPos;
                            const runLength = rleCheck.length;
                            const colors = rleCheck.colors;
                            
                            for (let i = 0; i < runLength; i++) {
                                if (pixelIndex < width * height) {
                                    const idx = pixelIndex * 4;
                                    imageData[idx] = colors.r;
                                    imageData[idx + 1] = colors.g;
                                    imageData[idx + 2] = colors.b;
                                    imageData[idx + 3] = 255;
                                    pixelIndex++;
                                }
                            }
                            x += runLength - 1;
                            continue;
                        }
                        
                        // Decode normal pixel
                        let r, g, b;
                        
                        if (this.colorEncoding === 'rgb') {
                            r = this.decodeColorValue(channelData, pos);
                            pos += samplesPerPixel;
                            
                            g = this.decodeColorValue(channelData, pos);
                            pos += samplesPerPixel;
                            
                            b = this.decodeColorValue(channelData, pos);
                            pos += samplesPerPixel;
                        } else {
                            const colors = this.decodeFMColors(channelData, pos, samplesPerPixel);
                            r = colors.r;
                            g = colors.g;
                            b = colors.b;
                            pos += samplesPerPixel;
                        }
                        
                        const idx = pixelIndex * 4;
                        imageData[idx] = r;
                        imageData[idx + 1] = g;
                        imageData[idx + 2] = b;
                        imageData[idx + 3] = 255;
                        
                        pixelIndex++;
                        
                        // Update progress
                        if (pixelIndex % 100 === 0) {
                            const progress = (pixelIndex / (width * height)) * 100;
                            this.updateDecodeProgress(progress);
                        }
                        
                        // Check if we've reached end of data
                        if (pos >= channelData.length - samplesPerPixel) {
                            break;
                        }
                    }
                }
                
                this.updateDecodeStatus('Decoding complete!');
                this.updateDecodeProgress(100);
                this.showNotification('Image decoded successfully!', 'success');
                
                return {
                    imageData,
                    width,
                    height
                };
            }

            // Find start of signal using Goertzel algorithm
            findStartOfSignal(channelData) {
                const blockSize = Math.floor(0.05 * this.sampleRate); // 50ms blocks
                
                for (let i = 0; i < channelData.length - blockSize; i += blockSize / 2) {
                    const block = channelData.slice(i, i + blockSize);
                    const amplitude = this.goertzel(block, this.startFreq, this.sampleRate);
                    
                    if (amplitude > 0.3) { // Threshold for detection
                        return i;
                    }
                }
                
                return -1;
            }

            // Goertzel algorithm for frequency detection
            goertzel(samples, targetFreq, sampleRate) {
                const omega = 2 * Math.PI * targetFreq / sampleRate;
                const coeff = 2 * Math.cos(omega);
                
                let q0 = 0, q1 = 0, q2 = 0;
                
                for (let i = 0; i < samples.length; i++) {
                    q0 = coeff * q1 - q2 + samples[i];
                    q2 = q1;
                    q1 = q0;
                }
                
                const real = q1 - q2 * Math.cos(omega);
                const imag = q2 * Math.sin(omega);
                
                return Math.sqrt(real * real + imag * imag) / samples.length;
            }

            // Decode number from dual-tone
            decodeNumber(channelData, pos) {
                const blockSize = Math.floor(0.05 * this.sampleRate);
                
                // Decode first byte
                const block1 = channelData.slice(pos, pos + blockSize);
                let maxAmplitude = 0;
                let byteValue = 0;
                
                for (let freq = 800; freq <= 800 + 255 * 8.6; freq += 8.6) {
                    const amplitude = this.goertzel(block1, freq, this.sampleRate);
                    if (amplitude > maxAmplitude) {
                        maxAmplitude = amplitude;
                        byteValue = Math.round((freq - 800) / 8.6);
                    }
                }
                
                let number = byteValue << 8;
                
                // Decode second byte
                const block2 = channelData.slice(pos + blockSize, pos + blockSize * 2);
                maxAmplitude = 0;
                byteValue = 0;
                
                for (let freq = 800; freq <= 800 + 255 * 8.6; freq += 8.6) {
                    const amplitude = this.goertzel(block2, freq, this.sampleRate);
                    if (amplitude > maxAmplitude) {
                        maxAmplitude = amplitude;
                        byteValue = Math.round((freq - 800) / 8.6);
                    }
                }
                
                number |= byteValue;
                return number;
            }

            // Decode color value from tone
            decodeColorValue(channelData, pos) {
                const blockSize = Math.floor(this.pixelDuration * this.sampleRate);
                const block = channelData.slice(pos, pos + blockSize);
                
                let maxAmplitude = 0;
                let bestValue = 0;
                
                // Scan frequencies from black to white
                for (let freq = this.blackFreq; freq <= this.whiteFreq; freq += 10) {
                    const amplitude = this.goertzel(block, freq, this.sampleRate);
                    if (amplitude > maxAmplitude) {
                        maxAmplitude = amplitude;
                        bestValue = Math.round(((freq - this.blackFreq) / (this.whiteFreq - this.blackFreq)) * 255);
                    }
                }
                
                return Math.max(0, Math.min(255, bestValue));
            }

            // Decode FM colors
            decodeFMColors(channelData, pos, blockSize) {
                const block = channelData.slice(pos, pos + blockSize);
                
                // Simple demodulation - in practice would need proper FM demodulation
                let rEnergy = 0, gEnergy = 0, bEnergy = 0;
                
                for (let i = 0; i < block.length; i++) {
                    const time = i / this.sampleRate;
                    rEnergy += Math.abs(block[i] * Math.sin(2 * Math.PI * 50 * time));
                    gEnergy += Math.abs(block[i] * Math.sin(2 * Math.PI * 100 * time));
                    bEnergy += Math.abs(block[i] * Math.sin(2 * Math.PI * 150 * time));
                }
                
                const maxEnergy = Math.max(rEnergy, gEnergy, bEnergy);
                return {
                    r: Math.round((rEnergy / maxEnergy) * 255),
                    g: Math.round((gEnergy / maxEnergy) * 255),
                    b: Math.round((bEnergy / maxEnergy) * 255)
                };
            }

            // Check for RLE marker
            checkForRLE(channelData, pos) {
                const markerSize = Math.floor(0.02 * this.sampleRate);
                
                // Check for RLE marker (2500 Hz)
                const markerBlock = channelData.slice(pos, pos + markerSize);
                const markerAmp = this.goertzel(markerBlock, 2500, this.sampleRate);
                
                if (markerAmp > 0.2) {
                    // Decode length
                    const lengthBlock = channelData.slice(pos + markerSize, pos + markerSize * 2);
                    let maxAmp = 0;
                    let length = 0;
                    
                    for (let freq = 1000; freq <= 2000; freq += 10) {
                        const amp = this.goertzel(lengthBlock, freq, this.sampleRate);
                        if (amp > maxAmp) {
                            maxAmp = amp;
                            length = Math.round((freq - 1000) / 10);
                        }
                    }
                    
                    // Get colors from next pixel (after RLE marker)
                    const colorPos = pos + markerSize * 2;
                    let colors = { r: 128, g: 128, b: 128 };
                    
                    // Try to decode colors (simplified)
                    if (this.colorEncoding === 'rgb') {
                        colors.r = this.decodeColorValue(channelData, colorPos);
                        colors.g = this.decodeColorValue(channelData, colorPos + Math.floor(this.pixelDuration * this.sampleRate));
                        colors.b = this.decodeColorValue(channelData, colorPos + Math.floor(this.pixelDuration * 2 * this.sampleRate));
                    }
                    
                    return {
                        isRLE: true,
                        length: length,
                        colors: colors,
                        newPos: colorPos + (this.colorEncoding === 'rgb' ? 
                            Math.floor(this.pixelDuration * 3 * this.sampleRate) : 
                            Math.floor(this.pixelDuration * this.sampleRate))
                    };
                }
                
                return { isRLE: false };
            }

            // Start microphone decoding
            async startMicrophoneDecoding() {
                try {
                    this.initAudio();
                    
                    // Request microphone access
                    this.micStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: this.sampleRate
                        } 
                    });
                    
                    // Create audio processing
                    const source = this.audioContext.createMediaStreamSource(this.micStream);
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 2048;
                    this.analyser.smoothingTimeConstant = 0.8;
                    
                    // Create processor for real-time analysis
                    this.micProcessor = this.audioContext.createScriptProcessor(4096, 1, 1);
                    
                    const buffer = new Float32Array(4096);
                    let bufferPos = 0;
                    const fullBufferSize = this.sampleRate * 10; // 10 seconds buffer
                    const fullBuffer = new Float32Array(fullBufferSize);
                    
                    this.micProcessor.onaudioprocess = (event) => {
                        const input = event.inputBuffer.getChannelData(0);
                        
                        // Update frequency display
                        this.updateFrequencyDisplay(input);
                        
                        // Fill buffer
                        for (let i = 0; i < input.length; i++) {
                            fullBuffer[bufferPos] = input[i];
                            bufferPos = (bufferPos + 1) % fullBufferSize;
                        }
                        
                        // Try to detect signal
                        this.detectSignalInBuffer(fullBuffer, bufferPos);
                    };
                    
                    source.connect(this.analyser);
                    this.analyser.connect(this.micProcessor);
                    this.micProcessor.connect(this.audioContext.destination);
                    
                    this.updateDecodeStatus('Microphone active - listening for WSSTV signal...');
                    this.setSyncLed(true, true);
                    this.showNotification('Microphone activated. Listening for SSTV signals...', 'success');
                    
                } catch (error) {
                    console.error('Microphone error:', error);
                    this.showNotification('Microphone access denied or failed.', 'error');
                }
            }

            // Stop microphone decoding
            stopMicrophoneDecoding() {
                if (this.micStream) {
                    this.micStream.getTracks().forEach(track => track.stop());
                    this.micStream = null;
                }
                if (this.micProcessor) {
                    this.micProcessor.disconnect();
                    this.micProcessor = null;
                }
                this.setSyncLed(false);
                this.updateDecodeStatus('Microphone stopped.');
            }

            // Update frequency display
            updateFrequencyDisplay(data) {
                const freqData = new Uint8Array(this.analyser.frequencyBinCount);
                this.analyser.getByteFrequencyData(freqData);
                
                // Find dominant frequency
                let maxIndex = 0;
                let maxValue = 0;
                
                for (let i = 0; i < freqData.length; i++) {
                    if (freqData[i] > maxValue) {
                        maxValue = freqData[i];
                        maxIndex = i;
                    }
                }
                
                const freq = maxIndex * this.audioContext.sampleRate / this.analyser.fftSize;
                
                // Update display
                document.getElementById('currentFreq').textContent = Math.round(freq) + ' Hz';
                
                // Update marker position
                const marker = document.getElementById('freqMarker');
                const percentage = ((freq - 800) / (3000 - 800)) * 100;
                marker.style.left = Math.min(100, Math.max(0, percentage)) + '%';
            }

            // Detect signal in microphone buffer
            detectSignalInBuffer(buffer, position) {
                // Simple signal detection - look for start frequency
                const windowSize = Math.floor(0.05 * this.sampleRate);
                const samples = [];
                
                // Get recent samples
                for (let i = 0; i < windowSize; i++) {
                    const idx = (position - windowSize + i + buffer.length) % buffer.length;
                    samples.push(buffer[idx]);
                }
                
                const amplitude = this.goertzel(samples, this.startFreq, this.sampleRate);
                
                if (amplitude > 0.25) {
                    this.showNotification('WSSTV signal detected!', 'success');
                    this.updateDecodeStatus('Signal detected - decoding...');
                    
                    // Extract the complete signal
                    this.extractAndDecodeSignal(buffer, position);
                }
            }

            // Extract and decode signal from buffer
            extractAndDecodeSignal(buffer, position) {
                // Stop listening
                this.stopMicrophoneDecoding();
                
                // Find start position
                let startPos = -1;
                const searchWindow = Math.floor(2 * this.sampleRate); // Search last 2 seconds
                
                for (let i = 0; i < searchWindow; i++) {
                    const idx = (position - i + buffer.length) % buffer.length;
                    const windowStart = Math.max(0, idx - Math.floor(0.05 * this.sampleRate));
                    const samples = [];
                    
                    for (let j = 0; j < Math.floor(0.05 * this.sampleRate); j++) {
                        const sampleIdx = (windowStart + j) % buffer.length;
                        samples.push(buffer[sampleIdx]);
                    }
                    
                    const amplitude = this.goertzel(samples, this.startFreq, this.sampleRate);
                    if (amplitude > 0.25) {
                        startPos = windowStart;
                        break;
                    }
                }
                
                if (startPos !== -1) {
                    // Extract signal (estimate 10 seconds max)
                    const maxSignalLength = Math.floor(10 * this.sampleRate);
                    const extracted = new Float32Array(maxSignalLength);
                    
                    for (let i = 0; i < maxSignalLength; i++) {
                        const idx = (startPos + i) % buffer.length;
                        extracted[i] = buffer[idx];
                    }
                    
                    // Create AudioBuffer and decode
                    const audioBuffer = this.audioContext.createBuffer(1, extracted.length, this.sampleRate);
                    audioBuffer.getChannelData(0).set(extracted);
                    
                    // Decode
                    this.decodeAudio(audioBuffer).then(result => {
                        // Display result
                        this.displayDecodedImage(result);
                    }).catch(error => {
                        this.showNotification('Decoding failed: ' + error.message, 'error');
                    });
                }
            }

            // Display decoded image
            displayDecodedImage(result) {
                const canvas = document.getElementById('decodedImage');
                const ctx = canvas.getContext('2d');
                const imageData = new ImageData(result.imageData, result.width, result.height);
                
                canvas.width = result.width;
                canvas.height = result.height;
                ctx.putImageData(imageData, 0, 0);
                
                document.getElementById('saveImageBtn').disabled = false;
            }

            // Play audio
            playAudio(buffer) {
                if (!this.audioContext) this.initAudio();
                
                this.stopAudio();
                
                this.sourceNode = this.audioContext.createBufferSource();
                this.sourceNode.buffer = buffer;
                this.sourceNode.connect(this.audioContext.destination);
                
                this.sourceNode.onended = () => {
                    this.isPlaying = false;
                    this.updatePlaybackStatus();
                };
                
                this.sourceNode.start();
                this.isPlaying = true;
                this.updatePlaybackStatus();
                this.showNotification('Playing encoded audio...', 'success');
            }

            // Stop audio
            stopAudio() {
                if (this.sourceNode) {
                    this.sourceNode.stop();
                    this.sourceNode.disconnect();
                    this.sourceNode = null;
                }
                this.isPlaying = false;
                this.updatePlaybackStatus();
            }

            // Save audio as WAV file
            saveAudioAsWAV(buffer, filename = 'wsstv_transmission.wav') {
                const wavBuffer = this.bufferToWav(buffer);
                const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showNotification('Audio saved as WAV file.', 'success');
            }

            // Convert AudioBuffer to WAV
            bufferToWav(buffer) {
                const numChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const format = 1; // PCM
                const bitDepth = 16;
                
                const bytesPerSample = bitDepth / 8;
                const blockAlign = numChannels * bytesPerSample;
                const byteRate = sampleRate * blockAlign;
                const dataSize = buffer.length * blockAlign;
                
                const bufferArray = new ArrayBuffer(44 + dataSize);
                const view = new DataView(bufferArray);
                
                // Write WAV header
                this.writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + dataSize, true);
                this.writeString(view, 8, 'WAVE');
                this.writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, format, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, bitDepth, true);
                this.writeString(view, 36, 'data');
                view.setUint32(40, dataSize, true);
                
                // Write audio data
                let offset = 44;
                for (let i = 0; i < buffer.length; i++) {
                    for (let channel = 0; channel < numChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        view.setInt16(offset, sample * 0x7FFF, true);
                        offset += 2;
                    }
                }
                
                return bufferArray;
            }

            writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            // Update methods
            updateStatus(text) {
                document.getElementById('encodeStatus').textContent = text;
            }

            updateProgress(percent) {
                document.getElementById('encodeProgress').style.width = percent + '%';
            }

            updateDecodeStatus(text) {
                document.getElementById('decodeStatus').textContent = text;
            }

            updateDecodeProgress(percent) {
                document.getElementById('decodeProgress').style.width = percent + '%';
            }

            updateDecodeInfo(text) {
                document.getElementById('decodeInfo').textContent = text;
            }

            updatePlaybackStatus() {
                const btn = document.getElementById('playBtn');
                btn.innerHTML = this.isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
            }

            setSyncLed(active, isRecording = false) {
                const led = document.getElementById('syncLed');
                led.classList.toggle('active', active && !isRecording);
                led.classList.toggle('recording', isRecording);
            }

            updateProtocolInfo() {
                document.getElementById('pixelRate').textContent = 
                    `${Math.round(1000 / this.pixelDuration)} pixels/sec`;
                document.getElementById('colorEncoding').textContent = 
                    this.colorEncoding === 'rgb' ? 'RGB Separate' : 'FM Encoding';
                document.getElementById('compressionStatus').textContent = 
                    this.useRLE ? 'RLE Enabled' : 'No Compression';
            }
        }

        // Application Controller
        class WSSTVApp {
            constructor() {
                this.protocol = new WSSTVProtocol();
                this.isMicActive = false;
                this.init();
            }

            init() {
                this.bindEvents();
                this.initCanvas();
                this.protocol.updateProtocolInfo();
            }

            bindEvents() {
                // Image selection
                document.getElementById('imageInput').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0]);
                });

                // Encoding
                document.getElementById('encodeBtn').addEventListener('click', async () => {
                    await this.encodeCurrentImage();
                });

                // Playback
                document.getElementById('playBtn').addEventListener('click', () => {
                    if (this.protocol.isPlaying) {
                        this.protocol.stopAudio();
                    } else if (this.protocol.audioBuffer) {
                        this.protocol.playAudio(this.protocol.audioBuffer);
                    }
                });

                document.getElementById('stopBtn').addEventListener('click', () => {
                    this.protocol.stopAudio();
                });

                // Save audio
                document.getElementById('saveBtn').addEventListener('click', () => {
                    if (this.protocol.audioBuffer) {
                        this.protocol.saveAudioAsWAV(this.protocol.audioBuffer);
                    }
                });

                // Settings
                document.getElementById('pixelDuration').addEventListener('input', (e) => {
                    this.protocol.pixelDuration = e.target.value / 1000;
                    document.getElementById('pixelDurationValue').textContent = e.target.value;
                    this.protocol.updateProtocolInfo();
                });

                document.getElementById('resolution').addEventListener('input', (e) => {
                    this.protocol.resolutionScale = e.target.value / 10;
                    document.getElementById('resolutionValue').textContent = this.protocol.resolutionScale.toFixed(1);
                });

                // Encoding modes
                document.getElementById('encodeRgb').addEventListener('click', (e) => {
                    this.protocol.colorEncoding = 'rgb';
                    document.getElementById('colorEncoding').textContent = 'RGB Separate';
                    e.target.classList.add('active');
                    document.getElementById('encodeFm').classList.remove('active');
                });

                document.getElementById('encodeFm').addEventListener('click', (e) => {
                    this.protocol.colorEncoding = 'fm';
                    document.getElementById('colorEncoding').textContent = 'FM Encoding';
                    e.target.classList.add('active');
                    document.getElementById('encodeRgb').classList.remove('active');
                });

                document.getElementById('enableRle').addEventListener('click', (e) => {
                    this.protocol.useRLE = !this.protocol.useRLE;
                    e.target.textContent = this.protocol.useRLE ? 
                        'üìâ RLE Enabled' : 'üìà RLE Disabled';
                    e.target.classList.toggle('active', this.protocol.useRLE);
                    this.protocol.updateProtocolInfo();
                });

                // Audio file input
                document.getElementById('audioInput').addEventListener('change', (e) => {
                    this.loadAudioFile(e.target.files[0]);
                });

                // Decoding
                document.getElementById('decodeBtn').addEventListener('click', async () => {
                    await this.decodeAudioFile();
                });

                // Microphone decoding
                document.getElementById('micBtn').addEventListener('click', () => {
                    if (this.isMicActive) {
                        this.protocol.stopMicrophoneDecoding();
                        this.isMicActive = false;
                        document.getElementById('micBtn').innerHTML = 'üé§ Decode from Microphone';
                    } else {
                        this.protocol.startMicrophoneDecoding();
                        this.isMicActive = true;
                        document.getElementById('micBtn').innerHTML = '‚èπÔ∏è Stop Microphone';
                    }
                });

                // Save image
                document.getElementById('saveImageBtn').addEventListener('click', () => {
                    this.saveDecodedImage();
                });
            }

            initCanvas() {
                this.waveformCanvas = document.getElementById('waveformCanvas');
                this.decodedCanvas = document.getElementById('decodedImage');
                
                // Set canvas dimensions
                const resizeCanvas = () => {
                    const waveformContainer = document.querySelector('.waveform');
                    this.waveformCanvas.width = waveformContainer.clientWidth - 30;
                    this.waveformCanvas.height = waveformContainer.clientHeight - 30;
                    
                    this.decodedCanvas.width = 400;
                    this.decodedCanvas.height = 300;
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }

            async loadImage(file) {
                if (!file) return;
                
                try {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // Limit size for performance
                            const maxSize = 400;
                            let width = img.width;
                            let height = img.height;
                            
                            if (width > maxSize || height > maxSize) {
                                const ratio = Math.min(maxSize / width, maxSize / height);
                                width = Math.floor(width * ratio);
                                height = Math.floor(height * ratio);
                            }
                            
                            canvas.width = width;
                            canvas.height = height;
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            this.protocol.currentImage = {
                                data: ctx.getImageData(0, 0, width, height),
                                width,
                                height
                            };
                            
                            // Display image
                            document.getElementById('sourceImage').src = e.target.result;
                            document.getElementById('sourceImage').style.display = 'block';
                            document.getElementById('noImageText').style.display = 'none';
                            
                            // Enable encode button
                            document.getElementById('encodeBtn').disabled = false;
                            
                            this.protocol.updateStatus(`Image loaded: ${width}x${height}`);
                            this.protocol.showNotification('Image loaded successfully!', 'success');
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                } catch (error) {
                    this.protocol.showNotification('Error loading image: ' + error.message, 'error');
                }
            }

            async encodeCurrentImage() {
                if (!this.protocol.currentImage) {
                    this.protocol.showNotification('Please select an image first!', 'error');
                    return;
                }
                
                try {
                    const { data, width, height } = this.protocol.currentImage;
                    const result = await this.protocol.encodeImage(data, width, height);
                    
                    // Enable playback controls
                    document.getElementById('playBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('saveBtn').disabled = false;
                    
                    // Draw waveform
                    this.drawWaveform(result.buffer);
                    
                } catch (error) {
                    console.error('Encoding error:', error);
                    this.protocol.updateStatus(`Error: ${error.message}`);
                    this.protocol.showNotification('Encoding failed: ' + error.message, 'error');
                }
            }

            async loadAudioFile(file) {
                if (!file) return;
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.protocol.initAudio();
                    const audioBuffer = await this.protocol.audioContext.decodeAudioData(arrayBuffer);
                    
                    this.protocol.audioBuffer = audioBuffer;
                    document.getElementById('decodeBtn').disabled = false;
                    
                    this.protocol.updateDecodeStatus(`Audio loaded: ${audioBuffer.duration.toFixed(2)}s`);
                    this.drawWaveform(audioBuffer);
                    this.protocol.showNotification('Audio file loaded successfully!', 'success');
                    
                } catch (error) {
                    console.error('Audio loading error:', error);
                    this.protocol.updateDecodeStatus(`Error: ${error.message}`);
                    this.protocol.showNotification('Error loading audio: ' + error.message, 'error');
                }
            }

            async decodeAudioFile() {
                if (!this.protocol.audioBuffer) {
                    this.protocol.showNotification('Please load an audio file first!', 'error');
                    return;
                }
                
                try {
                    const result = await this.protocol.decodeAudio(this.protocol.audioBuffer);
                    
                    // Display decoded image
                    const canvas = this.decodedCanvas;
                    const ctx = canvas.getContext('2d');
                    const imageData = new ImageData(result.imageData, result.width, result.height);
                    
                    canvas.width = result.width;
                    canvas.height = result.height;
                    ctx.putImageData(imageData, 0, 0);
                    
                    document.getElementById('saveImageBtn').disabled = false;
                    
                } catch (error) {
                    console.error('Decoding error:', error);
                    this.protocol.updateDecodeStatus(`Error: ${error.message}`);
                    this.protocol.showNotification('Decoding failed: ' + error.message, 'error');
                }
            }

            drawWaveform(audioBuffer) {
                const canvas = this.waveformCanvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                // Draw grid
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                
                // Horizontal lines
                for (let i = 0; i <= 5; i++) {
                    const y = (i / 5) * height;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // Vertical lines
                for (let i = 0; i <= 10; i++) {
                    const x = (i / 10) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                
                // Get channel data
                const data = audioBuffer.getChannelData(0);
                const step = Math.ceil(data.length / width);
                const amp = height / 2;
                
                // Draw waveform
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < width; i++) {
                    const index = Math.min(Math.floor(i * step), data.length - 1);
                    const value = data[index];
                    const x = i;
                    const y = amp + (value * amp * 0.8);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Mark start
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(0, 0, 4, height);
                
                // Mark estimated end of header
                const headerEnd = (1.0 / audioBuffer.duration) * width;
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(headerEnd - 2, 0, 4, height);
            }

            saveDecodedImage() {
                const canvas = this.decodedCanvas;
                const link = document.createElement('a');
                link.download = 'wsstv_decoded_image.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
                this.protocol.showNotification('Image saved successfully!', 'success');
            }
        }

        // Initialize application when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new WSSTVApp();
        });
    </script>
</body>
</html>
